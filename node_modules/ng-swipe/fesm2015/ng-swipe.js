import { EventEmitter, Directive, ElementRef, NgZone, Output, NgModule } from '@angular/core';
import { fromEvent } from 'rxjs';
import { map, switchMap, elementAt, filter, takeUntil, take, tap, takeWhile } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SwipeDirective {
    /**
     * @param {?} elementRef
     * @param {?} zone
     */
    constructor(elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        this.swipeMove = new EventEmitter();
        this.swipeEnd = new EventEmitter();
        /**
         * Property used to unsubscribe from all subscriptions on destroy event
         */
        this.alive = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const domElement = this.elementRef.nativeElement;
        /** @type {?} */
        const touchStarts = fromEvent(domElement, 'touchstart').pipe(map(this.touchEventToCoordinate));
        /** @type {?} */
        const touchMoves = fromEvent(domElement, 'touchmove').pipe(map(this.touchEventToCoordinate));
        /** @type {?} */
        const touchEnds = fromEvent(domElement, 'touchend').pipe(map(this.touchEventToCoordinate));
        /**
         * Move starts with direction: Pair the move start events with the 3rd subsequent move event,
         * but only if no touch end event happens in between
         * @type {?}
         */
        const moveStartsWithDirection = touchStarts.pipe(switchMap((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        (dragStartEvent) => touchMoves.pipe(elementAt(3), map((/**
         * @param {?} dragEvent
         * @return {?}
         */
        (dragEvent) => {
            /** @type {?} */
            const intialDeltaX = dragEvent.x - dragStartEvent.x;
            /** @type {?} */
            const initialDeltaY = dragEvent.y - dragStartEvent.y;
            return { x: dragStartEvent.x, y: dragStartEvent.y, intialDeltaX, initialDeltaY };
        }))))));
        /**
         * Vertical move starts: Keep only those move start events
         * where the 3rd subsequent move event is rather vertical than horizontal
         * @type {?}
         */
        const verticalMoveStarts = moveStartsWithDirection.pipe(filter((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        dragStartEvent => Math.abs(dragStartEvent.intialDeltaX) < Math.abs(dragStartEvent.initialDeltaY))));
        /**
         * Horizontal move starts: Keep only those move start events
         * where the 3rd subsequent move event is rather horizontal than vertical
         * @type {?}
         */
        const horizontalMoveStarts = moveStartsWithDirection.pipe(filter((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        dragStartEvent => Math.abs(dragStartEvent.intialDeltaX) >= Math.abs(dragStartEvent.initialDeltaY))));
        /**
         * Take the moves until touch ends
         * On move end emit swipe end event to parent element
         * @type {?}
         */
        const movesUntilEnds = (/**
         * @param {?} dragStartEvent
         * @param {?} direction
         * @return {?}
         */
        (dragStartEvent, direction) => touchMoves.pipe(map((/**
         * @param {?} dragEvent
         * @return {?}
         */
        dragEvent => this.getSwipeDistance(dragStartEvent, dragEvent))), takeUntil(touchEnds.pipe(take(1), map((/**
         * @param {?} dragEndEvent
         * @return {?}
         */
        dragEndEvent => this.getSwipeDistance(dragStartEvent, dragEndEvent))), tap((/**
         * @param {?} coordinates
         * @return {?}
         */
        (coordinates) => this.emitSwipeEndEvent(direction, coordinates)))))));
        /** @type {?} */
        const verticalMoves = verticalMoveStarts.pipe(switchMap((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        dragStartEvent => movesUntilEnds(dragStartEvent, 'y'))));
        /** @type {?} */
        const horizontalMoves = horizontalMoveStarts.pipe(switchMap((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        dragStartEvent => movesUntilEnds(dragStartEvent, 'x'))));
        /**
         * Run swipe subscriptions outside zone for better performance
         * On move emit swipe move event to parent element
         */
        this.zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            verticalMoves.pipe(takeWhile((/**
             * @return {?}
             */
            () => this.alive))).subscribe((/**
             * @param {?} coordinates
             * @return {?}
             */
            (coordinates) => this.emitSwipeMoveEvent('y', coordinates)));
            horizontalMoves.pipe(takeWhile((/**
             * @return {?}
             */
            () => this.alive))).subscribe((/**
             * @param {?} coordinates
             * @return {?}
             */
            (coordinates) => this.emitSwipeMoveEvent('x', coordinates)));
        }));
    }
    /**
     * Set alive property to false to unsubscribe from all subscriptions
     * @return {?}
     */
    ngOnDestroy() {
        this.alive = false;
    }
    /**
     * Format touch event to coordinates object that is easier to read
     * @param {?} touchEvent
     * @return {?}
     */
    touchEventToCoordinate(touchEvent) {
        return {
            x: touchEvent.changedTouches[0].clientX,
            y: touchEvent.changedTouches[0].clientY
        };
    }
    /**
     * @private
     * @param {?} dragStartEvent
     * @param {?} dragEvent
     * @return {?}
     */
    getSwipeDistance(dragStartEvent, dragEvent) {
        return {
            x: dragEvent.x - dragStartEvent.x,
            y: dragEvent.y - dragStartEvent.y
        };
    }
    /**
     * Emits swipe move event with calculated direction and distance
     * @private
     * @param {?} direction
     * @param {?} coordinates
     * @return {?}
     */
    emitSwipeMoveEvent(direction, coordinates) {
        this.swipeMove.emit({ direction, distance: coordinates[direction] });
    }
    /**
     * Emits swipe move event with calculated direction and distance
     * @private
     * @param {?} direction
     * @param {?} coordinates
     * @return {?}
     */
    emitSwipeEndEvent(direction, coordinates) {
        this.swipeEnd.emit({ direction, distance: coordinates[direction] });
    }
}
SwipeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngSwipe]'
            },] }
];
/** @nocollapse */
SwipeDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
SwipeDirective.propDecorators = {
    swipeMove: [{ type: Output }],
    swipeEnd: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SwipeModule {
}
SwipeModule.decorators = [
    { type: NgModule, args: [{
                declarations: [SwipeDirective],
                exports: [SwipeDirective]
            },] }
];

export { SwipeModule, SwipeDirective as Éµa };
//# sourceMappingURL=ng-swipe.js.map
