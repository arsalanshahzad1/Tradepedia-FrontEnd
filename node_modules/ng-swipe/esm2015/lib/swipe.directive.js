/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive should be added to HTML element that swipe action is listened on.
 * Callback function should be attached to host event 'swipeMove' or'swipeEnd' event depending on required functionality.
 * Event object contains two properties:
 * [direction]: 'y' | 'x'  - defines swipe direction is vertical or horizontal
 * [distance]: number - defines swipe length in pixels
 */
import { Directive, ElementRef, EventEmitter, NgZone, Output } from '@angular/core';
import { fromEvent } from 'rxjs';
import { elementAt, filter, map, switchMap, take, takeUntil, takeWhile, tap } from 'rxjs/operators';
export class SwipeDirective {
    /**
     * @param {?} elementRef
     * @param {?} zone
     */
    constructor(elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        this.swipeMove = new EventEmitter();
        this.swipeEnd = new EventEmitter();
        /**
         * Property used to unsubscribe from all subscriptions on destroy event
         */
        this.alive = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /** @type {?} */
        const domElement = this.elementRef.nativeElement;
        /** @type {?} */
        const touchStarts = fromEvent(domElement, 'touchstart').pipe(map(this.touchEventToCoordinate));
        /** @type {?} */
        const touchMoves = fromEvent(domElement, 'touchmove').pipe(map(this.touchEventToCoordinate));
        /** @type {?} */
        const touchEnds = fromEvent(domElement, 'touchend').pipe(map(this.touchEventToCoordinate));
        /**
         * Move starts with direction: Pair the move start events with the 3rd subsequent move event,
         * but only if no touch end event happens in between
         * @type {?}
         */
        const moveStartsWithDirection = touchStarts.pipe(switchMap((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        (dragStartEvent) => touchMoves.pipe(elementAt(3), map((/**
         * @param {?} dragEvent
         * @return {?}
         */
        (dragEvent) => {
            /** @type {?} */
            const intialDeltaX = dragEvent.x - dragStartEvent.x;
            /** @type {?} */
            const initialDeltaY = dragEvent.y - dragStartEvent.y;
            return { x: dragStartEvent.x, y: dragStartEvent.y, intialDeltaX, initialDeltaY };
        }))))));
        /**
         * Vertical move starts: Keep only those move start events
         * where the 3rd subsequent move event is rather vertical than horizontal
         * @type {?}
         */
        const verticalMoveStarts = moveStartsWithDirection.pipe(filter((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        dragStartEvent => Math.abs(dragStartEvent.intialDeltaX) < Math.abs(dragStartEvent.initialDeltaY))));
        /**
         * Horizontal move starts: Keep only those move start events
         * where the 3rd subsequent move event is rather horizontal than vertical
         * @type {?}
         */
        const horizontalMoveStarts = moveStartsWithDirection.pipe(filter((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        dragStartEvent => Math.abs(dragStartEvent.intialDeltaX) >= Math.abs(dragStartEvent.initialDeltaY))));
        /**
         * Take the moves until touch ends
         * On move end emit swipe end event to parent element
         * @type {?}
         */
        const movesUntilEnds = (/**
         * @param {?} dragStartEvent
         * @param {?} direction
         * @return {?}
         */
        (dragStartEvent, direction) => touchMoves.pipe(map((/**
         * @param {?} dragEvent
         * @return {?}
         */
        dragEvent => this.getSwipeDistance(dragStartEvent, dragEvent))), takeUntil(touchEnds.pipe(take(1), map((/**
         * @param {?} dragEndEvent
         * @return {?}
         */
        dragEndEvent => this.getSwipeDistance(dragStartEvent, dragEndEvent))), tap((/**
         * @param {?} coordinates
         * @return {?}
         */
        (coordinates) => this.emitSwipeEndEvent(direction, coordinates)))))));
        /** @type {?} */
        const verticalMoves = verticalMoveStarts.pipe(switchMap((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        dragStartEvent => movesUntilEnds(dragStartEvent, 'y'))));
        /** @type {?} */
        const horizontalMoves = horizontalMoveStarts.pipe(switchMap((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        dragStartEvent => movesUntilEnds(dragStartEvent, 'x'))));
        /**
         * Run swipe subscriptions outside zone for better performance
         * On move emit swipe move event to parent element
         */
        this.zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            verticalMoves.pipe(takeWhile((/**
             * @return {?}
             */
            () => this.alive))).subscribe((/**
             * @param {?} coordinates
             * @return {?}
             */
            (coordinates) => this.emitSwipeMoveEvent('y', coordinates)));
            horizontalMoves.pipe(takeWhile((/**
             * @return {?}
             */
            () => this.alive))).subscribe((/**
             * @param {?} coordinates
             * @return {?}
             */
            (coordinates) => this.emitSwipeMoveEvent('x', coordinates)));
        }));
    }
    /**
     * Set alive property to false to unsubscribe from all subscriptions
     * @return {?}
     */
    ngOnDestroy() {
        this.alive = false;
    }
    /**
     * Format touch event to coordinates object that is easier to read
     * @param {?} touchEvent
     * @return {?}
     */
    touchEventToCoordinate(touchEvent) {
        return {
            x: touchEvent.changedTouches[0].clientX,
            y: touchEvent.changedTouches[0].clientY
        };
    }
    /**
     * @private
     * @param {?} dragStartEvent
     * @param {?} dragEvent
     * @return {?}
     */
    getSwipeDistance(dragStartEvent, dragEvent) {
        return {
            x: dragEvent.x - dragStartEvent.x,
            y: dragEvent.y - dragStartEvent.y
        };
    }
    /**
     * Emits swipe move event with calculated direction and distance
     * @private
     * @param {?} direction
     * @param {?} coordinates
     * @return {?}
     */
    emitSwipeMoveEvent(direction, coordinates) {
        this.swipeMove.emit({ direction, distance: coordinates[direction] });
    }
    /**
     * Emits swipe move event with calculated direction and distance
     * @private
     * @param {?} direction
     * @param {?} coordinates
     * @return {?}
     */
    emitSwipeEndEvent(direction, coordinates) {
        this.swipeEnd.emit({ direction, distance: coordinates[direction] });
    }
}
SwipeDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngSwipe]'
            },] }
];
/** @nocollapse */
SwipeDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
SwipeDirective.propDecorators = {
    swipeMove: [{ type: Output }],
    swipeEnd: [{ type: Output }]
};
if (false) {
    /** @type {?} */
    SwipeDirective.prototype.swipeMove;
    /** @type {?} */
    SwipeDirective.prototype.swipeEnd;
    /**
     * Property used to unsubscribe from all subscriptions on destroy event
     * @type {?}
     * @private
     */
    SwipeDirective.prototype.alive;
    /**
     * @type {?}
     * @private
     */
    SwipeDirective.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    SwipeDirective.prototype.zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dpcGUuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmctc3dpcGUvIiwic291cmNlcyI6WyJsaWIvc3dpcGUuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBT0EsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBcUIsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3ZHLE9BQU8sRUFBRSxTQUFTLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDN0MsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQU9wRyxNQUFNLE9BQU8sY0FBYzs7Ozs7SUFVekIsWUFDVSxVQUFzQixFQUN0QixJQUFZO1FBRFosZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUN0QixTQUFJLEdBQUosSUFBSSxDQUFRO1FBVlosY0FBUyxHQUE2QixJQUFJLFlBQVksRUFBYyxDQUFDO1FBQ3JFLGFBQVEsR0FBNkIsSUFBSSxZQUFZLEVBQWMsQ0FBQzs7OztRQUt0RSxVQUFLLEdBQUcsSUFBSSxDQUFDO0lBS2xCLENBQUM7Ozs7SUFFSixRQUFROztjQUNBLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGFBQWE7O2NBRTFDLFdBQVcsR0FBaUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDOztjQUN0SCxVQUFVLEdBQWlDLFNBQVMsQ0FBQyxVQUFVLEVBQUUsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQzs7Y0FDcEgsU0FBUyxHQUFpQyxTQUFTLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxDQUFD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Q0FBOEU7Ozs7OztJQUs5RSwrQkFBcUI7Ozs7O0lBR25CLG9DQUE4Qjs7Ozs7SUFDOUIsOEJBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIERpcmVjdGl2ZSBzaG91bGQgYmUgYWRkZWQgdG8gSFRNTCBlbGVtZW50IHRoYXQgc3dpcGUgYWN0aW9uIGlzIGxpc3RlbmVkIG9uLlxyXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBzaG91bGQgYmUgYXR0YWNoZWQgdG8gaG9zdCBldmVudCAnc3dpcGVNb3ZlJyBvcidzd2lwZUVuZCcgZXZlbnQgZGVwZW5kaW5nIG9uIHJlcXVpcmVkIGZ1bmN0aW9uYWxpdHkuXHJcbiAqIEV2ZW50IG9iamVjdCBjb250YWlucyB0d28gcHJvcGVydGllczpcclxuICogW2RpcmVjdGlvbl06ICd5JyB8ICd4JyAgLSBkZWZpbmVzIHN3aXBlIGRpcmVjdGlvbiBpcyB2ZXJ0aWNhbCBvciBob3Jpem9udGFsXHJcbiAqIFtkaXN0YW5jZV06IG51bWJlciAtIGRlZmluZXMgc3dpcGUgbGVuZ3RoIGluIHBpeGVsc1xyXG4gKi9cclxuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIE5nWm9uZSwgT25EZXN0cm95LCBPbkluaXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBmcm9tRXZlbnQsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgZWxlbWVudEF0LCBmaWx0ZXIsIG1hcCwgc3dpdGNoTWFwLCB0YWtlLCB0YWtlVW50aWwsIHRha2VXaGlsZSwgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBTd2lwZUNvb3JkaW5hdGVzLCBTd2lwZURpcmVjdGlvbiwgU3dpcGVFdmVudCB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tuZ1N3aXBlXSdcclxufSlcclxuXHJcbmV4cG9ydCBjbGFzcyBTd2lwZURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcclxuXHJcbiAgQE91dHB1dCgpIHN3aXBlTW92ZTogRXZlbnRFbWl0dGVyPFN3aXBlRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxTd2lwZUV2ZW50PigpO1xyXG4gIEBPdXRwdXQoKSBzd2lwZUVuZDogRXZlbnRFbWl0dGVyPFN3aXBlRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxTd2lwZUV2ZW50PigpO1xyXG5cclxuICAvKipcclxuICAgKiBQcm9wZXJ0eSB1c2VkIHRvIHVuc3Vic2NyaWJlIGZyb20gYWxsIHN1YnNjcmlwdGlvbnMgb24gZGVzdHJveSBldmVudFxyXG4gICAqL1xyXG4gIHByaXZhdGUgYWxpdmUgPSB0cnVlO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZixcclxuICAgIHByaXZhdGUgem9uZTogTmdab25lXHJcbiAgKSB7fVxyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICAgIGNvbnN0IGRvbUVsZW1lbnQgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcclxuICAgIFxyXG4gICAgY29uc3QgdG91Y2hTdGFydHM6IE9ic2VydmFibGU8U3dpcGVDb29yZGluYXRlcz4gPSBmcm9tRXZlbnQoZG9tRWxlbWVudCwgJ3RvdWNoc3RhcnQnKS5waXBlKG1hcCh0aGlzLnRvdWNoRXZlbnRUb0Nvb3JkaW5hdGUpKTtcclxuICAgIGNvbnN0IHRvdWNoTW92ZXM6IE9ic2VydmFibGU8U3dpcGVDb29yZGluYXRlcz4gPSBmcm9tRXZlbnQoZG9tRWxlbWVudCwgJ3RvdWNobW92ZScpLnBpcGUobWFwKHRoaXMudG91Y2hFdmVudFRvQ29vcmRpbmF0ZSkpO1xyXG4gICAgY29uc3QgdG91Y2hFbmRzOiBPYnNlcnZhYmxlPFN3aXBlQ29vcmRpbmF0ZXM+ID0gZnJvbUV2ZW50KGRvbUVsZW1lbnQsICd0b3VjaGVuZCcpLnBpcGUobWFwKHRoaXMudG91Y2hFdmVudFRvQ29vcmRpbmF0ZSkpO1xyXG4gICAgXHJcbiAgICAvKipcclxuICAgICAqIE1vdmUgc3RhcnRzIHdpdGggZGlyZWN0aW9uOiBQYWlyIHRoZSBtb3ZlIHN0YXJ0IGV2ZW50cyB3aXRoIHRoZSAzcmQgc3Vic2VxdWVudCBtb3ZlIGV2ZW50LFxyXG4gICAgICogYnV0IG9ubHkgaWYgbm8gdG91Y2ggZW5kIGV2ZW50IGhhcHBlbnMgaW4gYmV0d2VlblxyXG4gICAgICovXHJcbiAgICBjb25zdCBtb3ZlU3RhcnRzV2l0aERpcmVjdGlvbiA9IHRvdWNoU3RhcnRzLnBpcGUoXHJcbiAgICAgIHN3aXRjaE1hcCgoZHJhZ1N0YXJ0RXZlbnQ6IFN3aXBlQ29vcmRpbmF0ZXMpID0+IHRvdWNoTW92ZXMucGlwZShcclxuICAgICAgICBlbGVtZW50QXQoMyksXHJcbiAgICAgICAgbWFwKChkcmFnRXZlbnQ6IFN3aXBlQ29vcmRpbmF0ZXMpID0+IHtcclxuICAgICAgICAgIGNvbnN0IGludGlhbERlbHRhWCA9IGRyYWdFdmVudC54IC0gZHJhZ1N0YXJ0RXZlbnQueDtcclxuICAgICAgICAgIGNvbnN0IGluaXRpYWxEZWx0YVkgPSBkcmFnRXZlbnQueSAtIGRyYWdTdGFydEV2ZW50Lnk7XHJcbiAgICAgICAgICByZXR1cm4ge3g6IGRyYWdTdGFydEV2ZW50LngsIHk6IGRyYWdTdGFydEV2ZW50LnksIGludGlhbERlbHRhWCwgaW5pdGlhbERlbHRhWX07XHJcbiAgICAgICAgfSlcclxuICAgICkpKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFZlcnRpY2FsIG1vdmUgc3RhcnRzOiBLZWVwIG9ubHkgdGhvc2UgbW92ZSBzdGFydCBldmVudHNcclxuICAgICAqIHdoZXJlIHRoZSAzcmQgc3Vic2VxdWVudCBtb3ZlIGV2ZW50IGlzIHJhdGhlciB2ZXJ0aWNhbCB0aGFuIGhvcml6b250YWxcclxuICAgICAqL1xyXG4gICAgY29uc3QgdmVydGljYWxNb3ZlU3RhcnRzID0gbW92ZVN0YXJ0c1dpdGhEaXJlY3Rpb24ucGlwZShcclxuICAgICAgZmlsdGVyKGRyYWdTdGFydEV2ZW50ID0+IE1hdGguYWJzKGRyYWdTdGFydEV2ZW50LmludGlhbERlbHRhWCkgPCBNYXRoLmFicyhkcmFnU3RhcnRFdmVudC5pbml0aWFsRGVsdGFZKVxyXG4gICAgKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIb3Jpem9udGFsIG1vdmUgc3RhcnRzOiBLZWVwIG9ubHkgdGhvc2UgbW92ZSBzdGFydCBldmVudHNcclxuICAgICAqIHdoZXJlIHRoZSAzcmQgc3Vic2VxdWVudCBtb3ZlIGV2ZW50IGlzIHJhdGhlciBob3Jpem9udGFsIHRoYW4gdmVydGljYWxcclxuICAgICAqL1xyXG4gICAgY29uc3QgaG9yaXpvbnRhbE1vdmVTdGFydHMgPSBtb3ZlU3RhcnRzV2l0aERpcmVjdGlvbi5waXBlKFxyXG4gICAgICBmaWx0ZXIoZHJhZ1N0YXJ0RXZlbnQgPT4gTWF0aC5hYnMoZHJhZ1N0YXJ0RXZlbnQuaW50aWFsRGVsdGFYKSA+PSBNYXRoLmFicyhkcmFnU3RhcnRFdmVudC5pbml0aWFsRGVsdGFZKSlcclxuICAgICk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUYWtlIHRoZSBtb3ZlcyB1bnRpbCB0b3VjaCBlbmRzXHJcbiAgICAgKiBPbiBtb3ZlIGVuZCBlbWl0IHN3aXBlIGVuZCBldmVudCB0byBwYXJlbnQgZWxlbWVudFxyXG4gICAgICovXHJcbiAgICBjb25zdCBtb3Zlc1VudGlsRW5kcyA9IChkcmFnU3RhcnRFdmVudDogYW55LCBkaXJlY3Rpb246IFN3aXBlRGlyZWN0aW9uKSA9PiB0b3VjaE1vdmVzLnBpcGUoXHJcbiAgICAgIG1hcChkcmFnRXZlbnQgPT4gdGhpcy5nZXRTd2lwZURpc3RhbmNlKGRyYWdTdGFydEV2ZW50LCBkcmFnRXZlbnQpKSxcclxuICAgICAgdGFrZVVudGlsKHRvdWNoRW5kcy5waXBlKFxyXG4gICAgICAgIHRha2UoMSksXHJcbiAgICAgICAgbWFwKGRyYWdFbmRFdmVudCA9PiB0aGlzLmdldFN3aXBlRGlzdGFuY2UoZHJhZ1N0YXJ0RXZlbnQsIGRyYWdFbmRFdmVudCkpLFxyXG4gICAgICAgIHRhcCgoY29vcmRpbmF0ZXM6IFN3aXBlQ29vcmRpbmF0ZXMpID0+IHRoaXMuZW1pdFN3aXBlRW5kRXZlbnQoZGlyZWN0aW9uLCBjb29yZGluYXRlcykpXHJcbiAgICApKSk7XHJcblxyXG4gICAgY29uc3QgdmVydGljYWxNb3ZlcyA9IHZlcnRpY2FsTW92ZVN0YXJ0cy5waXBlKFxyXG4gICAgICBzd2l0Y2hNYXAoZHJhZ1N0YXJ0RXZlbnQgPT4gbW92ZXNVbnRpbEVuZHMoZHJhZ1N0YXJ0RXZlbnQsICd5JykpXHJcbiAgICApO1xyXG4gICAgY29uc3QgaG9yaXpvbnRhbE1vdmVzID0gaG9yaXpvbnRhbE1vdmVTdGFydHMucGlwZShcclxuICAgICAgc3dpdGNoTWFwKGRyYWdTdGFydEV2ZW50ID0+IG1vdmVzVW50aWxFbmRzKGRyYWdTdGFydEV2ZW50LCAneCcpKVxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW4gc3dpcGUgc3Vic2NyaXB0aW9ucyBvdXRzaWRlIHpvbmUgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxyXG4gICAgICogT24gbW92ZSBlbWl0IHN3aXBlIG1vdmUgZXZlbnQgdG8gcGFyZW50IGVsZW1lbnRcclxuICAgICAqL1xyXG4gICAgdGhpcy56b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcclxuICAgICAgdmVydGljYWxNb3Zlcy5waXBlKFxyXG4gICAgICAgIHRha2VXaGlsZSgoKSA9PiB0aGlzLmFsaXZlKVxyXG4gICAgICApLnN1YnNjcmliZSgoY29vcmRpbmF0ZXM6IFN3aXBlQ29vcmRpbmF0ZXMpID0+IHRoaXMuZW1pdFN3aXBlTW92ZUV2ZW50KCd5JywgY29vcmRpbmF0ZXMpKTtcclxuICBcclxuICAgICAgaG9yaXpvbnRhbE1vdmVzLnBpcGUoXHJcbiAgICAgICAgdGFrZVdoaWxlKCgpID0+IHRoaXMuYWxpdmUpXHJcbiAgICAgICkuc3Vic2NyaWJlKChjb29yZGluYXRlczogU3dpcGVDb29yZGluYXRlcykgPT4gdGhpcy5lbWl0U3dpcGVNb3ZlRXZlbnQoJ3gnLCBjb29yZGluYXRlcykpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgYWxpdmUgcHJvcGVydHkgdG8gZmFsc2UgdG8gdW5zdWJzY3JpYmUgZnJvbSBhbGwgc3Vic2NyaXB0aW9uc1xyXG4gICAqL1xyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRm9ybWF0IHRvdWNoIGV2ZW50IHRvIGNvb3JkaW5hdGVzIG9iamVjdCB0aGF0IGlzIGVhc2llciB0byByZWFkXHJcbiAgICovXHJcbiAgcHVibGljIHRvdWNoRXZlbnRUb0Nvb3JkaW5hdGUodG91Y2hFdmVudDogVG91Y2hFdmVudCk6IFN3aXBlQ29vcmRpbmF0ZXMgIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCxcclxuICAgICAgeTogdG91Y2hFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZXHJcbiAgICB9O1xyXG4gIH1cclxuICBcclxuICBwcml2YXRlIGdldFN3aXBlRGlzdGFuY2UoZHJhZ1N0YXJ0RXZlbnQsIGRyYWdFdmVudCk6IFN3aXBlQ29vcmRpbmF0ZXMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogZHJhZ0V2ZW50LnggLSBkcmFnU3RhcnRFdmVudC54LFxyXG4gICAgICB5OiBkcmFnRXZlbnQueSAtIGRyYWdTdGFydEV2ZW50LnlcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFbWl0cyBzd2lwZSBtb3ZlIGV2ZW50IHdpdGggY2FsY3VsYXRlZCBkaXJlY3Rpb24gYW5kIGRpc3RhbmNlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBlbWl0U3dpcGVNb3ZlRXZlbnQoZGlyZWN0aW9uOiBTd2lwZURpcmVjdGlvbiwgY29vcmRpbmF0ZXM6IFN3aXBlQ29vcmRpbmF0ZXMpIHtcclxuICAgIHRoaXMuc3dpcGVNb3ZlLmVtaXQoe2RpcmVjdGlvbiwgZGlzdGFuY2U6IGNvb3JkaW5hdGVzW2RpcmVjdGlvbl19KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEVtaXRzIHN3aXBlIG1vdmUgZXZlbnQgd2l0aCBjYWxjdWxhdGVkIGRpcmVjdGlvbiBhbmQgZGlzdGFuY2VcclxuICAgKi9cclxuICBwcml2YXRlIGVtaXRTd2lwZUVuZEV2ZW50KGRpcmVjdGlvbjogU3dpcGVEaXJlY3Rpb24sIGNvb3JkaW5hdGVzOiBTd2lwZUNvb3JkaW5hdGVzKSB7XHJcbiAgICB0aGlzLnN3aXBlRW5kLmVtaXQoe2RpcmVjdGlvbiwgZGlzdGFuY2U6IGNvb3JkaW5hdGVzW2RpcmVjdGlvbl19KTtcclxuICB9XHJcbn1cclxuIl19