import { Directive, ElementRef, NgZone, Output, EventEmitter, NgModule } from '@angular/core';
import { fromEvent } from 'rxjs';
import { map, switchMap, elementAt, filter, takeUntil, take, tap, takeWhile } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SwipeDirective = /** @class */ (function () {
    function SwipeDirective(elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        this.swipeMove = new EventEmitter();
        this.swipeEnd = new EventEmitter();
        /**
         * Property used to unsubscribe from all subscriptions on destroy event
         */
        this.alive = true;
    }
    /**
     * @return {?}
     */
    SwipeDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var domElement = this.elementRef.nativeElement;
        /** @type {?} */
        var touchStarts = fromEvent(domElement, 'touchstart').pipe(map(this.touchEventToCoordinate));
        /** @type {?} */
        var touchMoves = fromEvent(domElement, 'touchmove').pipe(map(this.touchEventToCoordinate));
        /** @type {?} */
        var touchEnds = fromEvent(domElement, 'touchend').pipe(map(this.touchEventToCoordinate));
        /**
         * Move starts with direction: Pair the move start events with the 3rd subsequent move event,
         * but only if no touch end event happens in between
         * @type {?}
         */
        var moveStartsWithDirection = touchStarts.pipe(switchMap((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        function (dragStartEvent) { return touchMoves.pipe(elementAt(3), map((/**
         * @param {?} dragEvent
         * @return {?}
         */
        function (dragEvent) {
            /** @type {?} */
            var intialDeltaX = dragEvent.x - dragStartEvent.x;
            /** @type {?} */
            var initialDeltaY = dragEvent.y - dragStartEvent.y;
            return { x: dragStartEvent.x, y: dragStartEvent.y, intialDeltaX: intialDeltaX, initialDeltaY: initialDeltaY };
        }))); })));
        /**
         * Vertical move starts: Keep only those move start events
         * where the 3rd subsequent move event is rather vertical than horizontal
         * @type {?}
         */
        var verticalMoveStarts = moveStartsWithDirection.pipe(filter((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        function (dragStartEvent) { return Math.abs(dragStartEvent.intialDeltaX) < Math.abs(dragStartEvent.initialDeltaY); })));
        /**
         * Horizontal move starts: Keep only those move start events
         * where the 3rd subsequent move event is rather horizontal than vertical
         * @type {?}
         */
        var horizontalMoveStarts = moveStartsWithDirection.pipe(filter((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        function (dragStartEvent) { return Math.abs(dragStartEvent.intialDeltaX) >= Math.abs(dragStartEvent.initialDeltaY); })));
        /**
         * Take the moves until touch ends
         * On move end emit swipe end event to parent element
         * @type {?}
         */
        var movesUntilEnds = (/**
         * @param {?} dragStartEvent
         * @param {?} direction
         * @return {?}
         */
        function (dragStartEvent, direction) { return touchMoves.pipe(map((/**
         * @param {?} dragEvent
         * @return {?}
         */
        function (dragEvent) { return _this.getSwipeDistance(dragStartEvent, dragEvent); })), takeUntil(touchEnds.pipe(take(1), map((/**
         * @param {?} dragEndEvent
         * @return {?}
         */
        function (dragEndEvent) { return _this.getSwipeDistance(dragStartEvent, dragEndEvent); })), tap((/**
         * @param {?} coordinates
         * @return {?}
         */
        function (coordinates) { return _this.emitSwipeEndEvent(direction, coordinates); }))))); });
        /** @type {?} */
        var verticalMoves = verticalMoveStarts.pipe(switchMap((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        function (dragStartEvent) { return movesUntilEnds(dragStartEvent, 'y'); })));
        /** @type {?} */
        var horizontalMoves = horizontalMoveStarts.pipe(switchMap((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        function (dragStartEvent) { return movesUntilEnds(dragStartEvent, 'x'); })));
        /**
         * Run swipe subscriptions outside zone for better performance
         * On move emit swipe move event to parent element
         */
        this.zone.runOutsideAngular((/**
         * @return {?}
         */
        function () {
            verticalMoves.pipe(takeWhile((/**
             * @return {?}
             */
            function () { return _this.alive; }))).subscribe((/**
             * @param {?} coordinates
             * @return {?}
             */
            function (coordinates) { return _this.emitSwipeMoveEvent('y', coordinates); }));
            horizontalMoves.pipe(takeWhile((/**
             * @return {?}
             */
            function () { return _this.alive; }))).subscribe((/**
             * @param {?} coordinates
             * @return {?}
             */
            function (coordinates) { return _this.emitSwipeMoveEvent('x', coordinates); }));
        }));
    };
    /**
     * Set alive property to false to unsubscribe from all subscriptions
     */
    /**
     * Set alive property to false to unsubscribe from all subscriptions
     * @return {?}
     */
    SwipeDirective.prototype.ngOnDestroy = /**
     * Set alive property to false to unsubscribe from all subscriptions
     * @return {?}
     */
    function () {
        this.alive = false;
    };
    /**
     * Format touch event to coordinates object that is easier to read
     */
    /**
     * Format touch event to coordinates object that is easier to read
     * @param {?} touchEvent
     * @return {?}
     */
    SwipeDirective.prototype.touchEventToCoordinate = /**
     * Format touch event to coordinates object that is easier to read
     * @param {?} touchEvent
     * @return {?}
     */
    function (touchEvent) {
        return {
            x: touchEvent.changedTouches[0].clientX,
            y: touchEvent.changedTouches[0].clientY
        };
    };
    /**
     * @private
     * @param {?} dragStartEvent
     * @param {?} dragEvent
     * @return {?}
     */
    SwipeDirective.prototype.getSwipeDistance = /**
     * @private
     * @param {?} dragStartEvent
     * @param {?} dragEvent
     * @return {?}
     */
    function (dragStartEvent, dragEvent) {
        return {
            x: dragEvent.x - dragStartEvent.x,
            y: dragEvent.y - dragStartEvent.y
        };
    };
    /**
     * Emits swipe move event with calculated direction and distance
     */
    /**
     * Emits swipe move event with calculated direction and distance
     * @private
     * @param {?} direction
     * @param {?} coordinates
     * @return {?}
     */
    SwipeDirective.prototype.emitSwipeMoveEvent = /**
     * Emits swipe move event with calculated direction and distance
     * @private
     * @param {?} direction
     * @param {?} coordinates
     * @return {?}
     */
    function (direction, coordinates) {
        this.swipeMove.emit({ direction: direction, distance: coordinates[direction] });
    };
    /**
     * Emits swipe move event with calculated direction and distance
     */
    /**
     * Emits swipe move event with calculated direction and distance
     * @private
     * @param {?} direction
     * @param {?} coordinates
     * @return {?}
     */
    SwipeDirective.prototype.emitSwipeEndEvent = /**
     * Emits swipe move event with calculated direction and distance
     * @private
     * @param {?} direction
     * @param {?} coordinates
     * @return {?}
     */
    function (direction, coordinates) {
        this.swipeEnd.emit({ direction: direction, distance: coordinates[direction] });
    };
    SwipeDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[ngSwipe]'
                },] }
    ];
    /** @nocollapse */
    SwipeDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone }
    ]; };
    SwipeDirective.propDecorators = {
        swipeMove: [{ type: Output }],
        swipeEnd: [{ type: Output }]
    };
    return SwipeDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var SwipeModule = /** @class */ (function () {
    function SwipeModule() {
    }
    SwipeModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [SwipeDirective],
                    exports: [SwipeDirective]
                },] }
    ];
    return SwipeModule;
}());

export { SwipeModule, SwipeDirective as Éµa };
//# sourceMappingURL=ng-swipe.js.map
