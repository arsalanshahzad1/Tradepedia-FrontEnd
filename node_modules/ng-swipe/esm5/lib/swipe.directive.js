/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive should be added to HTML element that swipe action is listened on.
 * Callback function should be attached to host event 'swipeMove' or'swipeEnd' event depending on required functionality.
 * Event object contains two properties:
 * [direction]: 'y' | 'x'  - defines swipe direction is vertical or horizontal
 * [distance]: number - defines swipe length in pixels
 */
import { Directive, ElementRef, EventEmitter, NgZone, Output } from '@angular/core';
import { fromEvent } from 'rxjs';
import { elementAt, filter, map, switchMap, take, takeUntil, takeWhile, tap } from 'rxjs/operators';
var SwipeDirective = /** @class */ (function () {
    function SwipeDirective(elementRef, zone) {
        this.elementRef = elementRef;
        this.zone = zone;
        this.swipeMove = new EventEmitter();
        this.swipeEnd = new EventEmitter();
        /**
         * Property used to unsubscribe from all subscriptions on destroy event
         */
        this.alive = true;
    }
    /**
     * @return {?}
     */
    SwipeDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var domElement = this.elementRef.nativeElement;
        /** @type {?} */
        var touchStarts = fromEvent(domElement, 'touchstart').pipe(map(this.touchEventToCoordinate));
        /** @type {?} */
        var touchMoves = fromEvent(domElement, 'touchmove').pipe(map(this.touchEventToCoordinate));
        /** @type {?} */
        var touchEnds = fromEvent(domElement, 'touchend').pipe(map(this.touchEventToCoordinate));
        /**
         * Move starts with direction: Pair the move start events with the 3rd subsequent move event,
         * but only if no touch end event happens in between
         * @type {?}
         */
        var moveStartsWithDirection = touchStarts.pipe(switchMap((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        function (dragStartEvent) { return touchMoves.pipe(elementAt(3), map((/**
         * @param {?} dragEvent
         * @return {?}
         */
        function (dragEvent) {
            /** @type {?} */
            var intialDeltaX = dragEvent.x - dragStartEvent.x;
            /** @type {?} */
            var initialDeltaY = dragEvent.y - dragStartEvent.y;
            return { x: dragStartEvent.x, y: dragStartEvent.y, intialDeltaX: intialDeltaX, initialDeltaY: initialDeltaY };
        }))); })));
        /**
         * Vertical move starts: Keep only those move start events
         * where the 3rd subsequent move event is rather vertical than horizontal
         * @type {?}
         */
        var verticalMoveStarts = moveStartsWithDirection.pipe(filter((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        function (dragStartEvent) { return Math.abs(dragStartEvent.intialDeltaX) < Math.abs(dragStartEvent.initialDeltaY); })));
        /**
         * Horizontal move starts: Keep only those move start events
         * where the 3rd subsequent move event is rather horizontal than vertical
         * @type {?}
         */
        var horizontalMoveStarts = moveStartsWithDirection.pipe(filter((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        function (dragStartEvent) { return Math.abs(dragStartEvent.intialDeltaX) >= Math.abs(dragStartEvent.initialDeltaY); })));
        /**
         * Take the moves until touch ends
         * On move end emit swipe end event to parent element
         * @type {?}
         */
        var movesUntilEnds = (/**
         * @param {?} dragStartEvent
         * @param {?} direction
         * @return {?}
         */
        function (dragStartEvent, direction) { return touchMoves.pipe(map((/**
         * @param {?} dragEvent
         * @return {?}
         */
        function (dragEvent) { return _this.getSwipeDistance(dragStartEvent, dragEvent); })), takeUntil(touchEnds.pipe(take(1), map((/**
         * @param {?} dragEndEvent
         * @return {?}
         */
        function (dragEndEvent) { return _this.getSwipeDistance(dragStartEvent, dragEndEvent); })), tap((/**
         * @param {?} coordinates
         * @return {?}
         */
        function (coordinates) { return _this.emitSwipeEndEvent(direction, coordinates); }))))); });
        /** @type {?} */
        var verticalMoves = verticalMoveStarts.pipe(switchMap((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        function (dragStartEvent) { return movesUntilEnds(dragStartEvent, 'y'); })));
        /** @type {?} */
        var horizontalMoves = horizontalMoveStarts.pipe(switchMap((/**
         * @param {?} dragStartEvent
         * @return {?}
         */
        function (dragStartEvent) { return movesUntilEnds(dragStartEvent, 'x'); })));
        /**
         * Run swipe subscriptions outside zone for better performance
         * On move emit swipe move event to parent element
         */
        this.zone.runOutsideAngular((/**
         * @return {?}
         */
        function () {
            verticalMoves.pipe(takeWhile((/**
             * @return {?}
             */
            function () { return _this.alive; }))).subscribe((/**
             * @param {?} coordinates
             * @return {?}
             */
            function (coordinates) { return _this.emitSwipeMoveEvent('y', coordinates); }));
            horizontalMoves.pipe(takeWhile((/**
             * @return {?}
             */
            function () { return _this.alive; }))).subscribe((/**
             * @param {?} coordinates
             * @return {?}
             */
            function (coordinates) { return _this.emitSwipeMoveEvent('x', coordinates); }));
        }));
    };
    /**
     * Set alive property to false to unsubscribe from all subscriptions
     */
    /**
     * Set alive property to false to unsubscribe from all subscriptions
     * @return {?}
     */
    SwipeDirective.prototype.ngOnDestroy = /**
     * Set alive property to false to unsubscribe from all subscriptions
     * @return {?}
     */
    function () {
        this.alive = false;
    };
    /**
     * Format touch event to coordinates object that is easier to read
     */
    /**
     * Format touch event to coordinates object that is easier to read
     * @param {?} touchEvent
     * @return {?}
     */
    SwipeDirective.prototype.touchEventToCoordinate = /**
     * Format touch event to coordinates object that is easier to read
     * @param {?} touchEvent
     * @return {?}
     */
    function (touchEvent) {
        return {
            x: touchEvent.changedTouches[0].clientX,
            y: touchEvent.changedTouches[0].clientY
        };
    };
    /**
     * @private
     * @param {?} dragStartEvent
     * @param {?} dragEvent
     * @return {?}
     */
    SwipeDirective.prototype.getSwipeDistance = /**
     * @private
     * @param {?} dragStartEvent
     * @param {?} dragEvent
     * @return {?}
     */
    function (dragStartEvent, dragEvent) {
        return {
            x: dragEvent.x - dragStartEvent.x,
            y: dragEvent.y - dragStartEvent.y
        };
    };
    /**
     * Emits swipe move event with calculated direction and distance
     */
    /**
     * Emits swipe move event with calculated direction and distance
     * @private
     * @param {?} direction
     * @param {?} coordinates
     * @return {?}
     */
    SwipeDirective.prototype.emitSwipeMoveEvent = /**
     * Emits swipe move event with calculated direction and distance
     * @private
     * @param {?} direction
     * @param {?} coordinates
     * @return {?}
     */
    function (direction, coordinates) {
        this.swipeMove.emit({ direction: direction, distance: coordinates[direction] });
    };
    /**
     * Emits swipe move event with calculated direction and distance
     */
    /**
     * Emits swipe move event with calculated direction and distance
     * @private
     * @param {?} direction
     * @param {?} coordinates
     * @return {?}
     */
    SwipeDirective.prototype.emitSwipeEndEvent = /**
     * Emits swipe move event with calculated direction and distance
     * @private
     * @param {?} direction
     * @param {?} coordinates
     * @return {?}
     */
    function (direction, coordinates) {
        this.swipeEnd.emit({ direction: direction, distance: coordinates[direction] });
    };
    SwipeDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[ngSwipe]'
                },] }
    ];
    /** @nocollapse */
    SwipeDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone }
    ]; };
    SwipeDirective.propDecorators = {
        swipeMove: [{ type: Output }],
        swipeEnd: [{ type: Output }]
    };
    return SwipeDirective;
}());
export { SwipeDirective };
if (false) {
    /** @type {?} */
    SwipeDirective.prototype.swipeMove;
    /** @type {?} */
    SwipeDirective.prototype.swipeEnd;
    /**
     * Property used to unsubscribe from all subscriptions on destroy event
     * @type {?}
     * @private
     */
    SwipeDirective.prototype.alive;
    /**
     * @type {?}
     * @private
     */
    SwipeDirective.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    SwipeDirective.prototype.zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3dpcGUuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmctc3dpcGUvIiwic291cmNlcyI6WyJsaWIvc3dpcGUuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBT0EsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBcUIsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3ZHLE9BQU8sRUFBRSxTQUFTLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDN0MsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUdwRztJQWNFLHdCQUNVLFVBQXNCLEVBQ3RCLElBQVk7UUFEWixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ3RCLFNBQUksR0FBSixJQUFJLENBQVE7UUFWWixjQUFTLEdBQTZCLElBQUksWUFBWSxFQUFjLENBQUM7UUFDckUsYUFBUSxHQUE2QixJQUFJLFlBQVksRUFBYyxDQUFDOzs7O1FBS3RFLFVBQUssR0FBRyxJQUFJLENBQUM7SUFLbEIsQ0FBQzs7OztJQUVKLGlDQUFROzs7SUFBUjtRQUFBLGlCQXFFQzs7WUFwRU8sVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYTs7WUFFMUMsV0FBVyxHQUFpQyxTQUFTLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLHNCQUFzQixDQUFDLENBQUM7O1lBQ3RILFVBQVUsR0FBaUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxXQUFXLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDOztZQUNwSCxTQUFTLEdBQWlDLFNBQVMsQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQzs7Ozs7O1lBTWxILHVCQUF1QixHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQzlDLFNBQVM7Ozs7UUFBQyxVQUFDLGNBQWdDLElBQUssT0FBQSxVQUFVLENBQUMsSUFBSSxDQUM3RCxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQ1osR0FBRzs7OztRQUFDLFVBQUMsU0FBMkI7O2dCQUN4QixZQUFZLEdBQUcsU0FBUyxDQUFDLENBQUMsR0FBRyxjQUFjLENBQUMsQ0FBQzs7Z0JBQzdDLGFBQWEsR0FBRyxTQUFTLENBQUMsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDO1lBQ3BELE9BQU8sRUFBQyxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsY0FBYyxDQUFDLENBQUMsRUFBRSxZQUFZLGNBQUEsRUFBRSxhQUFhLGVBQUEsRUFBQyxDQUFDO1FBQ2pGLENBQUMsRUFBQyxDQUNMLEVBUGlELENBT2pELEVBQUMsQ0FBQzs7Ozs7O1lBTUcsa0JBQWtCLEdBQUcsdUJBQXVCLENBQUMsSUFBSSxDQUNyRCxNQUFNOzs7O1FBQUMsVUFBQSxjQUFjLElBQUksT0FBQSxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsRUFBOUUsQ0FBOEUsRUFDeEcsQ0FBQzs7Ozs7O1lBTUksb0JBQW9CLEdBQUcsdUJBQXVCLENBQUMsSUFBSSxDQUN2RCxNQUFNOzs7O1FBQUMsVUFBQSxjQUFjLElBQUksT0FBQSxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxhQUFhLENBQUMsRUFBL0UsQ0FBK0UsRUFBQyxDQUMxRzs7Ozs7O1lBTUssY0FBYzs7Ozs7UUFBRyxVQUFDLGNBQW1CLEVBQUUsU0FBeUIsSUFBSyxPQUFBLFVBQVUsQ0FBQyxJQUFJLENBQ3hGLEdBQUc7Ozs7UUFBQyxVQUFBLFNBQVMsSUFBSSxPQUFBLEtBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxjQUFjLEVBQUUsU0FBUyxDQUFDLEVBQWhELENBQWdELEVBQUMsRUFDbEUsU0FBUyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQ3RCLElBQUksQ0FBQyxDQUFDLENBQUMsRUFDUCxHQUFHOzs7O1FBQUMsVUFBQSxZQUFZLElBQUksT0FBQSxLQUFJLENBQUMsZ0JBQWdCLENBQUMsY0FBYyxFQUFFLFlBQVksQ0FBQyxFQUFuRCxDQUFtRCxFQUFDLEVBQ3hFLEdBQUc7Ozs7UUFBQyxVQUFDLFdBQTZCLElBQUssT0FBQSxLQUFJLENBQUMsaUJBQWlCLENBQUMsU0FBUyxFQUFFLFdBQVcsQ0FBQyxFQUE5QyxDQUE4QyxFQUFDLENBQ3pGLENBQUMsQ0FBQyxFQU53RSxDQU14RSxDQUFBOztZQUVHLGFBQWEsR0FBRyxrQkFBa0IsQ0FBQyxJQUFJLENBQzNDLFNBQVM7Ozs7UUFBQyxVQUFBLGNBQWMsSUFBSSxPQUFBLGNBQWMsQ0FBQyxjQUFjLEVBQUUsR0FBRyxDQUFDLEVBQW5DLENBQW1DLEVBQUMsQ0FDakU7O1lBQ0ssZUFBZSxHQUFHLG9CQUFvQixDQUFDLElBQUksQ0FDL0MsU0FBUzs7OztRQUFDLFVBQUEsY0FBYyxJQUFJLE9BQUEsY0FBYyxDQUFDLGNBQWMsRUFBRSxHQUFHLENBQUMsRUFBbkMsQ0FBbUMsRUFBQyxDQUNqRTtRQUVEOzs7V0FHRztRQUNILElBQUksQ0FBQyxJQUFJLENBQUMsaUJBQWlCOzs7UUFBQztZQUMxQixhQUFhLENBQUMsSUFBSSxDQUNoQixTQUFTOzs7WUFBQyxjQUFNLE9BQUEsS0FBSSxDQUFDLEtBQUssRUFBVixDQUFVLEVBQUMsQ0FDNUIsQ0FBQyxTQUFTOzs7O1lBQUMsVUFBQyxXQUE2QixJQUFLLE9BQUEsS0FBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsRUFBRSxXQUFXLENBQUMsRUFBekMsQ0FBeUMsRUFBQyxDQUFDO1lBRTFGLGVBQWUsQ0FBQyxJQUFJLENBQ2xCLFNBQVM7OztZQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMsS0FBSyxFQUFWLENBQVUsRUFBQyxDQUM1QixDQUFDLFNBQVM7Ozs7WUFBQyxVQUFDLFdBQTZCLElBQUssT0FBQSxLQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxFQUFFLFdBQVcsQ0FBQyxFQUF6QyxDQUF5QyxFQUFDLENBQUM7UUFDNUYsQ0FBQyxFQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7O09BRUc7Ozs7O0lBQ0gsb0NBQVc7Ozs7SUFBWDtRQUNFLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3JCLENBQUM7SUFFRDs7T0FFRzs7Ozs7O0lBQ0ksK0NBQXNCOzs7OztJQUE3QixVQUE4QixVQUFzQjtRQUNsRCxPQUFPO1lBQ0wsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTztZQUN2QyxDQUFDLEVBQUUsVUFBVSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPO1NBQ3hDLENBQUM7SUFDSixDQUFDOzs7Ozs7O0lBRU8seUNBQWdCOzs7Ozs7SUFBeEIsVUFBeUIsY0FBYyxFQUFFLFNBQVM7UUFDaEQsT0FBTztZQUNMLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDO1lBQ2pDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDO1NBQ2xDLENBQUM7SUFDSixDQUFDO0lBRUQ7O09BRUc7Ozs7Ozs7O0lBQ0ssMkNBQWtCOzs7Ozs7O0lBQTFCLFVBQTJCLFNBQXlCLEVBQUUsV0FBNkI7UUFDakYsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsRUFBQyxTQUFTLFdBQUEsRUFBRSxRQUFRLEVBQUUsV0FBVyxDQUFDLFNBQVMsQ0FBQyxFQUFDLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQ7O09BRUc7Ozs7Ozs7O0lBQ0ssMENBQWlCOzs7Ozs7O0lBQXpCLFVBQTBCLFNBQXlCLEVBQUUsV0FBNkI7UUFDaEYsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBQyxTQUFTLFdBQUEsRUFBRSxRQUFRLEVBQUUsV0FBVyxDQUFDLFNBQVMsQ0FBQyxFQUFDLENBQUMsQ0FBQztJQUNwRSxDQUFDOztnQkE5SEYsU0FBUyxTQUFDO29CQUNULFFBQVEsRUFBRSxXQUFXO2lCQUN0Qjs7OztnQkFQbUIsVUFBVTtnQkFBZ0IsTUFBTTs7OzRCQVdqRCxNQUFNOzJCQUNOLE1BQU07O0lBd0hULHFCQUFDO0NBQUEsQUEvSEQsSUErSEM7U0EzSFksY0FBYzs7O0lBRXpCLG1DQUErRTs7SUFDL0Usa0NBQThFOzs7Ozs7SUFLOUUsK0JBQXFCOzs7OztJQUduQixvQ0FBOEI7Ozs7O0lBQzlCLDhCQUFvQiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBEaXJlY3RpdmUgc2hvdWxkIGJlIGFkZGVkIHRvIEhUTUwgZWxlbWVudCB0aGF0IHN3aXBlIGFjdGlvbiBpcyBsaXN0ZW5lZCBvbi5cclxuICogQ2FsbGJhY2sgZnVuY3Rpb24gc2hvdWxkIGJlIGF0dGFjaGVkIHRvIGhvc3QgZXZlbnQgJ3N3aXBlTW92ZScgb3Inc3dpcGVFbmQnIGV2ZW50IGRlcGVuZGluZyBvbiByZXF1aXJlZCBmdW5jdGlvbmFsaXR5LlxyXG4gKiBFdmVudCBvYmplY3QgY29udGFpbnMgdHdvIHByb3BlcnRpZXM6XHJcbiAqIFtkaXJlY3Rpb25dOiAneScgfCAneCcgIC0gZGVmaW5lcyBzd2lwZSBkaXJlY3Rpb24gaXMgdmVydGljYWwgb3IgaG9yaXpvbnRhbFxyXG4gKiBbZGlzdGFuY2VdOiBudW1iZXIgLSBkZWZpbmVzIHN3aXBlIGxlbmd0aCBpbiBwaXhlbHNcclxuICovXHJcbmltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBOZ1pvbmUsIE9uRGVzdHJveSwgT25Jbml0LCBPdXRwdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgZnJvbUV2ZW50LCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGVsZW1lbnRBdCwgZmlsdGVyLCBtYXAsIHN3aXRjaE1hcCwgdGFrZSwgdGFrZVVudGlsLCB0YWtlV2hpbGUsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgU3dpcGVDb29yZGluYXRlcywgU3dpcGVEaXJlY3Rpb24sIFN3aXBlRXZlbnQgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdbbmdTd2lwZV0nXHJcbn0pXHJcblxyXG5leHBvcnQgY2xhc3MgU3dpcGVEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XHJcblxyXG4gIEBPdXRwdXQoKSBzd2lwZU1vdmU6IEV2ZW50RW1pdHRlcjxTd2lwZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8U3dpcGVFdmVudD4oKTtcclxuICBAT3V0cHV0KCkgc3dpcGVFbmQ6IEV2ZW50RW1pdHRlcjxTd2lwZUV2ZW50PiA9IG5ldyBFdmVudEVtaXR0ZXI8U3dpcGVFdmVudD4oKTtcclxuXHJcbiAgLyoqXHJcbiAgICogUHJvcGVydHkgdXNlZCB0byB1bnN1YnNjcmliZSBmcm9tIGFsbCBzdWJzY3JpcHRpb25zIG9uIGRlc3Ryb3kgZXZlbnRcclxuICAgKi9cclxuICBwcml2YXRlIGFsaXZlID0gdHJ1ZTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXHJcbiAgICBwcml2YXRlIHpvbmU6IE5nWm9uZVxyXG4gICkge31cclxuXHJcbiAgbmdPbkluaXQoKSB7XHJcbiAgICBjb25zdCBkb21FbGVtZW50ID0gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XHJcbiAgICBcclxuICAgIGNvbnN0IHRvdWNoU3RhcnRzOiBPYnNlcnZhYmxlPFN3aXBlQ29vcmRpbmF0ZXM+ID0gZnJvbUV2ZW50KGRvbUVsZW1lbnQsICd0b3VjaHN0YXJ0JykucGlwZShtYXAodGhpcy50b3VjaEV2ZW50VG9Db29yZGluYXRlKSk7XHJcbiAgICBjb25zdCB0b3VjaE1vdmVzOiBPYnNlcnZhYmxlPFN3aXBlQ29vcmRpbmF0ZXM+ID0gZnJvbUV2ZW50KGRvbUVsZW1lbnQsICd0b3VjaG1vdmUnKS5waXBlKG1hcCh0aGlzLnRvdWNoRXZlbnRUb0Nvb3JkaW5hdGUpKTtcclxuICAgIGNvbnN0IHRvdWNoRW5kczogT2JzZXJ2YWJsZTxTd2lwZUNvb3JkaW5hdGVzPiA9IGZyb21FdmVudChkb21FbGVtZW50LCAndG91Y2hlbmQnKS5waXBlKG1hcCh0aGlzLnRvdWNoRXZlbnRUb0Nvb3JkaW5hdGUpKTtcclxuICAgIFxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlIHN0YXJ0cyB3aXRoIGRpcmVjdGlvbjogUGFpciB0aGUgbW92ZSBzdGFydCBldmVudHMgd2l0aCB0aGUgM3JkIHN1YnNlcXVlbnQgbW92ZSBldmVudCxcclxuICAgICAqIGJ1dCBvbmx5IGlmIG5vIHRvdWNoIGVuZCBldmVudCBoYXBwZW5zIGluIGJldHdlZW5cclxuICAgICAqL1xyXG4gICAgY29uc3QgbW92ZVN0YXJ0c1dpdGhEaXJlY3Rpb24gPSB0b3VjaFN0YXJ0cy5waXBlKFxyXG4gICAgICBzd2l0Y2hNYXAoKGRyYWdTdGFydEV2ZW50OiBTd2lwZUNvb3JkaW5hdGVzKSA9PiB0b3VjaE1vdmVzLnBpcGUoXHJcbiAgICAgICAgZWxlbWVudEF0KDMpLFxyXG4gICAgICAgIG1hcCgoZHJhZ0V2ZW50OiBTd2lwZUNvb3JkaW5hdGVzKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBpbnRpYWxEZWx0YVggPSBkcmFnRXZlbnQueCAtIGRyYWdTdGFydEV2ZW50Lng7XHJcbiAgICAgICAgICBjb25zdCBpbml0aWFsRGVsdGFZID0gZHJhZ0V2ZW50LnkgLSBkcmFnU3RhcnRFdmVudC55O1xyXG4gICAgICAgICAgcmV0dXJuIHt4OiBkcmFnU3RhcnRFdmVudC54LCB5OiBkcmFnU3RhcnRFdmVudC55LCBpbnRpYWxEZWx0YVgsIGluaXRpYWxEZWx0YVl9O1xyXG4gICAgICAgIH0pXHJcbiAgICApKSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJ0aWNhbCBtb3ZlIHN0YXJ0czogS2VlcCBvbmx5IHRob3NlIG1vdmUgc3RhcnQgZXZlbnRzXHJcbiAgICAgKiB3aGVyZSB0aGUgM3JkIHN1YnNlcXVlbnQgbW92ZSBldmVudCBpcyByYXRoZXIgdmVydGljYWwgdGhhbiBob3Jpem9udGFsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IHZlcnRpY2FsTW92ZVN0YXJ0cyA9IG1vdmVTdGFydHNXaXRoRGlyZWN0aW9uLnBpcGUoXHJcbiAgICAgIGZpbHRlcihkcmFnU3RhcnRFdmVudCA9PiBNYXRoLmFicyhkcmFnU3RhcnRFdmVudC5pbnRpYWxEZWx0YVgpIDwgTWF0aC5hYnMoZHJhZ1N0YXJ0RXZlbnQuaW5pdGlhbERlbHRhWSlcclxuICAgICkpO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSG9yaXpvbnRhbCBtb3ZlIHN0YXJ0czogS2VlcCBvbmx5IHRob3NlIG1vdmUgc3RhcnQgZXZlbnRzXHJcbiAgICAgKiB3aGVyZSB0aGUgM3JkIHN1YnNlcXVlbnQgbW92ZSBldmVudCBpcyByYXRoZXIgaG9yaXpvbnRhbCB0aGFuIHZlcnRpY2FsXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGhvcml6b250YWxNb3ZlU3RhcnRzID0gbW92ZVN0YXJ0c1dpdGhEaXJlY3Rpb24ucGlwZShcclxuICAgICAgZmlsdGVyKGRyYWdTdGFydEV2ZW50ID0+IE1hdGguYWJzKGRyYWdTdGFydEV2ZW50LmludGlhbERlbHRhWCkgPj0gTWF0aC5hYnMoZHJhZ1N0YXJ0RXZlbnQuaW5pdGlhbERlbHRhWSkpXHJcbiAgICApO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGFrZSB0aGUgbW92ZXMgdW50aWwgdG91Y2ggZW5kc1xyXG4gICAgICogT24gbW92ZSBlbmQgZW1pdCBzd2lwZSBlbmQgZXZlbnQgdG8gcGFyZW50IGVsZW1lbnRcclxuICAgICAqL1xyXG4gICAgY29uc3QgbW92ZXNVbnRpbEVuZHMgPSAoZHJhZ1N0YXJ0RXZlbnQ6IGFueSwgZGlyZWN0aW9uOiBTd2lwZURpcmVjdGlvbikgPT4gdG91Y2hNb3Zlcy5waXBlKFxyXG4gICAgICBtYXAoZHJhZ0V2ZW50ID0+IHRoaXMuZ2V0U3dpcGVEaXN0YW5jZShkcmFnU3RhcnRFdmVudCwgZHJhZ0V2ZW50KSksXHJcbiAgICAgIHRha2VVbnRpbCh0b3VjaEVuZHMucGlwZShcclxuICAgICAgICB0YWtlKDEpLFxyXG4gICAgICAgIG1hcChkcmFnRW5kRXZlbnQgPT4gdGhpcy5nZXRTd2lwZURpc3RhbmNlKGRyYWdTdGFydEV2ZW50LCBkcmFnRW5kRXZlbnQpKSxcclxuICAgICAgICB0YXAoKGNvb3JkaW5hdGVzOiBTd2lwZUNvb3JkaW5hdGVzKSA9PiB0aGlzLmVtaXRTd2lwZUVuZEV2ZW50KGRpcmVjdGlvbiwgY29vcmRpbmF0ZXMpKVxyXG4gICAgKSkpO1xyXG5cclxuICAgIGNvbnN0IHZlcnRpY2FsTW92ZXMgPSB2ZXJ0aWNhbE1vdmVTdGFydHMucGlwZShcclxuICAgICAgc3dpdGNoTWFwKGRyYWdTdGFydEV2ZW50ID0+IG1vdmVzVW50aWxFbmRzKGRyYWdTdGFydEV2ZW50LCAneScpKVxyXG4gICAgKTtcclxuICAgIGNvbnN0IGhvcml6b250YWxNb3ZlcyA9IGhvcml6b250YWxNb3ZlU3RhcnRzLnBpcGUoXHJcbiAgICAgIHN3aXRjaE1hcChkcmFnU3RhcnRFdmVudCA9PiBtb3Zlc1VudGlsRW5kcyhkcmFnU3RhcnRFdmVudCwgJ3gnKSlcclxuICAgICk7XHJcbiAgICBcclxuICAgIC8qKlxyXG4gICAgICogUnVuIHN3aXBlIHN1YnNjcmlwdGlvbnMgb3V0c2lkZSB6b25lIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2VcclxuICAgICAqIE9uIG1vdmUgZW1pdCBzd2lwZSBtb3ZlIGV2ZW50IHRvIHBhcmVudCBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIHRoaXMuem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XHJcbiAgICAgIHZlcnRpY2FsTW92ZXMucGlwZShcclxuICAgICAgICB0YWtlV2hpbGUoKCkgPT4gdGhpcy5hbGl2ZSlcclxuICAgICAgKS5zdWJzY3JpYmUoKGNvb3JkaW5hdGVzOiBTd2lwZUNvb3JkaW5hdGVzKSA9PiB0aGlzLmVtaXRTd2lwZU1vdmVFdmVudCgneScsIGNvb3JkaW5hdGVzKSk7XHJcbiAgXHJcbiAgICAgIGhvcml6b250YWxNb3Zlcy5waXBlKFxyXG4gICAgICAgIHRha2VXaGlsZSgoKSA9PiB0aGlzLmFsaXZlKVxyXG4gICAgICApLnN1YnNjcmliZSgoY29vcmRpbmF0ZXM6IFN3aXBlQ29vcmRpbmF0ZXMpID0+IHRoaXMuZW1pdFN3aXBlTW92ZUV2ZW50KCd4JywgY29vcmRpbmF0ZXMpKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGFsaXZlIHByb3BlcnR5IHRvIGZhbHNlIHRvIHVuc3Vic2NyaWJlIGZyb20gYWxsIHN1YnNjcmlwdGlvbnNcclxuICAgKi9cclxuICBuZ09uRGVzdHJveSgpIHtcclxuICAgIHRoaXMuYWxpdmUgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZvcm1hdCB0b3VjaCBldmVudCB0byBjb29yZGluYXRlcyBvYmplY3QgdGhhdCBpcyBlYXNpZXIgdG8gcmVhZFxyXG4gICAqL1xyXG4gIHB1YmxpYyB0b3VjaEV2ZW50VG9Db29yZGluYXRlKHRvdWNoRXZlbnQ6IFRvdWNoRXZlbnQpOiBTd2lwZUNvb3JkaW5hdGVzICB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiB0b3VjaEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFgsXHJcbiAgICAgIHk6IHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WVxyXG4gICAgfTtcclxuICB9XHJcbiAgXHJcbiAgcHJpdmF0ZSBnZXRTd2lwZURpc3RhbmNlKGRyYWdTdGFydEV2ZW50LCBkcmFnRXZlbnQpOiBTd2lwZUNvb3JkaW5hdGVzIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHg6IGRyYWdFdmVudC54IC0gZHJhZ1N0YXJ0RXZlbnQueCxcclxuICAgICAgeTogZHJhZ0V2ZW50LnkgLSBkcmFnU3RhcnRFdmVudC55XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW1pdHMgc3dpcGUgbW92ZSBldmVudCB3aXRoIGNhbGN1bGF0ZWQgZGlyZWN0aW9uIGFuZCBkaXN0YW5jZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgZW1pdFN3aXBlTW92ZUV2ZW50KGRpcmVjdGlvbjogU3dpcGVEaXJlY3Rpb24sIGNvb3JkaW5hdGVzOiBTd2lwZUNvb3JkaW5hdGVzKSB7XHJcbiAgICB0aGlzLnN3aXBlTW92ZS5lbWl0KHtkaXJlY3Rpb24sIGRpc3RhbmNlOiBjb29yZGluYXRlc1tkaXJlY3Rpb25dfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFbWl0cyBzd2lwZSBtb3ZlIGV2ZW50IHdpdGggY2FsY3VsYXRlZCBkaXJlY3Rpb24gYW5kIGRpc3RhbmNlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBlbWl0U3dpcGVFbmRFdmVudChkaXJlY3Rpb246IFN3aXBlRGlyZWN0aW9uLCBjb29yZGluYXRlczogU3dpcGVDb29yZGluYXRlcykge1xyXG4gICAgdGhpcy5zd2lwZUVuZC5lbWl0KHtkaXJlY3Rpb24sIGRpc3RhbmNlOiBjb29yZGluYXRlc1tkaXJlY3Rpb25dfSk7XHJcbiAgfVxyXG59XHJcbiJdfQ==