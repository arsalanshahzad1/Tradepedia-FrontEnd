(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('ng-swipe', ['exports', '@angular/core', 'rxjs', 'rxjs/operators'], factory) :
    (global = global || self, factory(global['ng-swipe'] = {}, global.ng.core, global.rxjs, global.rxjs.operators));
}(this, function (exports, core, rxjs, operators) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SwipeDirective = /** @class */ (function () {
        function SwipeDirective(elementRef, zone) {
            this.elementRef = elementRef;
            this.zone = zone;
            this.swipeMove = new core.EventEmitter();
            this.swipeEnd = new core.EventEmitter();
            /**
             * Property used to unsubscribe from all subscriptions on destroy event
             */
            this.alive = true;
        }
        /**
         * @return {?}
         */
        SwipeDirective.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var domElement = this.elementRef.nativeElement;
            /** @type {?} */
            var touchStarts = rxjs.fromEvent(domElement, 'touchstart').pipe(operators.map(this.touchEventToCoordinate));
            /** @type {?} */
            var touchMoves = rxjs.fromEvent(domElement, 'touchmove').pipe(operators.map(this.touchEventToCoordinate));
            /** @type {?} */
            var touchEnds = rxjs.fromEvent(domElement, 'touchend').pipe(operators.map(this.touchEventToCoordinate));
            /**
             * Move starts with direction: Pair the move start events with the 3rd subsequent move event,
             * but only if no touch end event happens in between
             * @type {?}
             */
            var moveStartsWithDirection = touchStarts.pipe(operators.switchMap((/**
             * @param {?} dragStartEvent
             * @return {?}
             */
            function (dragStartEvent) { return touchMoves.pipe(operators.elementAt(3), operators.map((/**
             * @param {?} dragEvent
             * @return {?}
             */
            function (dragEvent) {
                /** @type {?} */
                var intialDeltaX = dragEvent.x - dragStartEvent.x;
                /** @type {?} */
                var initialDeltaY = dragEvent.y - dragStartEvent.y;
                return { x: dragStartEvent.x, y: dragStartEvent.y, intialDeltaX: intialDeltaX, initialDeltaY: initialDeltaY };
            }))); })));
            /**
             * Vertical move starts: Keep only those move start events
             * where the 3rd subsequent move event is rather vertical than horizontal
             * @type {?}
             */
            var verticalMoveStarts = moveStartsWithDirection.pipe(operators.filter((/**
             * @param {?} dragStartEvent
             * @return {?}
             */
            function (dragStartEvent) { return Math.abs(dragStartEvent.intialDeltaX) < Math.abs(dragStartEvent.initialDeltaY); })));
            /**
             * Horizontal move starts: Keep only those move start events
             * where the 3rd subsequent move event is rather horizontal than vertical
             * @type {?}
             */
            var horizontalMoveStarts = moveStartsWithDirection.pipe(operators.filter((/**
             * @param {?} dragStartEvent
             * @return {?}
             */
            function (dragStartEvent) { return Math.abs(dragStartEvent.intialDeltaX) >= Math.abs(dragStartEvent.initialDeltaY); })));
            /**
             * Take the moves until touch ends
             * On move end emit swipe end event to parent element
             * @type {?}
             */
            var movesUntilEnds = (/**
             * @param {?} dragStartEvent
             * @param {?} direction
             * @return {?}
             */
            function (dragStartEvent, direction) { return touchMoves.pipe(operators.map((/**
             * @param {?} dragEvent
             * @return {?}
             */
            function (dragEvent) { return _this.getSwipeDistance(dragStartEvent, dragEvent); })), operators.takeUntil(touchEnds.pipe(operators.take(1), operators.map((/**
             * @param {?} dragEndEvent
             * @return {?}
             */
            function (dragEndEvent) { return _this.getSwipeDistance(dragStartEvent, dragEndEvent); })), operators.tap((/**
             * @param {?} coordinates
             * @return {?}
             */
            function (coordinates) { return _this.emitSwipeEndEvent(direction, coordinates); }))))); });
            /** @type {?} */
            var verticalMoves = verticalMoveStarts.pipe(operators.switchMap((/**
             * @param {?} dragStartEvent
             * @return {?}
             */
            function (dragStartEvent) { return movesUntilEnds(dragStartEvent, 'y'); })));
            /** @type {?} */
            var horizontalMoves = horizontalMoveStarts.pipe(operators.switchMap((/**
             * @param {?} dragStartEvent
             * @return {?}
             */
            function (dragStartEvent) { return movesUntilEnds(dragStartEvent, 'x'); })));
            /**
             * Run swipe subscriptions outside zone for better performance
             * On move emit swipe move event to parent element
             */
            this.zone.runOutsideAngular((/**
             * @return {?}
             */
            function () {
                verticalMoves.pipe(operators.takeWhile((/**
                 * @return {?}
                 */
                function () { return _this.alive; }))).subscribe((/**
                 * @param {?} coordinates
                 * @return {?}
                 */
                function (coordinates) { return _this.emitSwipeMoveEvent('y', coordinates); }));
                horizontalMoves.pipe(operators.takeWhile((/**
                 * @return {?}
                 */
                function () { return _this.alive; }))).subscribe((/**
                 * @param {?} coordinates
                 * @return {?}
                 */
                function (coordinates) { return _this.emitSwipeMoveEvent('x', coordinates); }));
            }));
        };
        /**
         * Set alive property to false to unsubscribe from all subscriptions
         */
        /**
         * Set alive property to false to unsubscribe from all subscriptions
         * @return {?}
         */
        SwipeDirective.prototype.ngOnDestroy = /**
         * Set alive property to false to unsubscribe from all subscriptions
         * @return {?}
         */
        function () {
            this.alive = false;
        };
        /**
         * Format touch event to coordinates object that is easier to read
         */
        /**
         * Format touch event to coordinates object that is easier to read
         * @param {?} touchEvent
         * @return {?}
         */
        SwipeDirective.prototype.touchEventToCoordinate = /**
         * Format touch event to coordinates object that is easier to read
         * @param {?} touchEvent
         * @return {?}
         */
        function (touchEvent) {
            return {
                x: touchEvent.changedTouches[0].clientX,
                y: touchEvent.changedTouches[0].clientY
            };
        };
        /**
         * @private
         * @param {?} dragStartEvent
         * @param {?} dragEvent
         * @return {?}
         */
        SwipeDirective.prototype.getSwipeDistance = /**
         * @private
         * @param {?} dragStartEvent
         * @param {?} dragEvent
         * @return {?}
         */
        function (dragStartEvent, dragEvent) {
            return {
                x: dragEvent.x - dragStartEvent.x,
                y: dragEvent.y - dragStartEvent.y
            };
        };
        /**
         * Emits swipe move event with calculated direction and distance
         */
        /**
         * Emits swipe move event with calculated direction and distance
         * @private
         * @param {?} direction
         * @param {?} coordinates
         * @return {?}
         */
        SwipeDirective.prototype.emitSwipeMoveEvent = /**
         * Emits swipe move event with calculated direction and distance
         * @private
         * @param {?} direction
         * @param {?} coordinates
         * @return {?}
         */
        function (direction, coordinates) {
            this.swipeMove.emit({ direction: direction, distance: coordinates[direction] });
        };
        /**
         * Emits swipe move event with calculated direction and distance
         */
        /**
         * Emits swipe move event with calculated direction and distance
         * @private
         * @param {?} direction
         * @param {?} coordinates
         * @return {?}
         */
        SwipeDirective.prototype.emitSwipeEndEvent = /**
         * Emits swipe move event with calculated direction and distance
         * @private
         * @param {?} direction
         * @param {?} coordinates
         * @return {?}
         */
        function (direction, coordinates) {
            this.swipeEnd.emit({ direction: direction, distance: coordinates[direction] });
        };
        SwipeDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[ngSwipe]'
                    },] }
        ];
        /** @nocollapse */
        SwipeDirective.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.NgZone }
        ]; };
        SwipeDirective.propDecorators = {
            swipeMove: [{ type: core.Output }],
            swipeEnd: [{ type: core.Output }]
        };
        return SwipeDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SwipeModule = /** @class */ (function () {
        function SwipeModule() {
        }
        SwipeModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [SwipeDirective],
                        exports: [SwipeDirective]
                    },] }
        ];
        return SwipeModule;
    }());

    exports.SwipeModule = SwipeModule;
    exports.ɵa = SwipeDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=ng-swipe.umd.js.map
